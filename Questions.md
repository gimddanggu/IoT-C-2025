### Q1. int main()과 void main()의 차이
A1. main 앞의 `int`, `void` 는 main 함수의 출력형태를 나타낸다. 
따라서 int main() 에서는 return 0; 을 반드시 써야되고,
void main()에서는 return 0; 을 생략해도 된다.

기본적으로 C언어 표준안에서는 void main을 허용하지 않는다
-> main 함수가 반환하는 값은 해당 프로그램의 종료 상태를 의미하므로 종료상태가 없다는 의미인 void main 형식은 원칙적으로 잘못 되었기 때문
하지만 main 함수의 반환값은 이용할 일이 없기 때문에 개발자 입장에서는 귀찮고 불편한 일이다.
따라서 컴파일러 개발자 입장에서 개발자의 편의성을 위해 void main 문법이 생긴 것이다.

### Q2. scanf 함수의 서식 지정자로 인해 받는 데이터의 타입이 결정되는가?
#### scanf()
- 형식
```c
int scanf(const char *format, ...);
```

- 반환값
    - 정상적으로 입력을 받아 변수에 저장하면 1반환(입력받은 변수 개수)
    - 입력 실패시 EOF(-1) 반환
- 동작과정
    1. 표준 입력 대기
    2. 입력값을 서식문자로 변환
    3. 변수에 저장
    4. 반환값 결정

- 주의할 점
    1. **주소 연산자** 필수
        변수의 값을 변경해야 하므로 **반드시** 변수의 메모리 주소를 전달
    2. 입력 버퍼 문제
    scanf가 데이터를 읽고 나서 입력 버퍼에 개행 문자(\n)가 남는 경우가 있어서 이후 입력이 꼬일 수 있음
    
- 입력 버퍼 문제 해결 방법
    - getchar() 사용
    - fflush(stdin) 사용 (Windows에서만)
    - while (getchar() != '\n');


#### 2개의 입력 값을 받았을 때 4 엔터를 입력한다면?
```c
scanf("%d %d", &num1, &num2);
// 입력: 4 ↵
``` 
scanf는 사용자의 입력을 계속해서 기다림
사용자가 두 번째 숫자를 입력하고 다시 엔터를 눌러야 입력 종료됨

#### 숫자가 아닌 값 입력했을 경우?
```c
scanf("%d %d", &num1, &num2);
// 입력 50 abc
```
scanf 반환값: 1 
num2의 값은 초기화되지않거나 쓰레기 값이 남아있음
입력버퍼에 남아있는 값: → `abc\n` 다음 입력을 받을 때 이전 입력의 찌꺼기가 남아 오류발생할 수 있음

### Q3. 공백을 무시하는 형식지정자?
→ 입력을 받을 때 앞에 남아 있는 공백 문자(스페이스, \t, \n)를 자동으로 건너뛰는 형식 지정자를 의미함.  

📌 공백 문자를 자동으로 무시하는 형식 지정자

- %d (정수)
- %f (실수)
- %s (문자열)
- %u (부호 없는 정수)
- %o (8진수)
- %x (16진수)
- %e, %g, %lf (실수 관련)  


📌 공백 문자를 무시하지 않는 형식 지정자
- %c (문자) ❌ 공백을 무시하지 않음!
- scanf("%c", &ch); → 앞에 남아 있는 개행 문자(\n)까지 입력받을 수 있음.
- 해결방법
    - getchar() 사용
    - scanf(" %c", &ch);처럼 %c 앞에 공백 추가  

### Q4. char을 %d로 출력하는 건 되는데, %d로 입력하는 건 왜 안 됨??
char는 내부적으로 정수(ASCII 코드 값)로 저장되므로, %d로 출력하면 char 값을 int로 변환해서 출력 가능    </br>   char는 1바이트(sizeof(char) = 1), 하지만 %d는 int(4바이트) 크기를 요구함.
scanf("%d", &ch);을 실행하면, 입력된 숫자(예: 65)를 4바이트 크기의 정수(int)로 읽으려 함.
그런데 ch는 1바이트 크기이므로 메모리 크기가 맞지 않아서 잘못된 값이 저장될 가능성이 있음

1kbyte = > 1024byte
k = 2^10
m = k*k = 2^20
g = m*k = 2^30