### Q1. int main()과 void main()의 차이
A1. main 앞의 `int`, `void` 는 main 함수의 출력형태를 나타낸다. 
따라서 int main() 에서는 return 0; 을 반드시 써야되고,
void main()에서는 return 0; 을 생략해도 된다.

기본적으로 C언어 표준안에서는 void main을 허용하지 않는다
-> main 함수가 반환하는 값은 해당 프로그램의 종료 상태를 의미하므로 종료상태가 없다는 의미인 void main 형식은 원칙적으로 잘못 되었기 때문
하지만 main 함수의 반환값은 이용할 일이 없기 때문에 개발자 입장에서는 귀찮고 불편한 일이다.
따라서 컴파일러 개발자 입장에서 개발자의 편의성을 위해 void main 문법이 생긴 것이다.

### Q2. scanf 함수의 서식 지정자로 인해 받는 데이터의 타입이 결정되는가?
#### scanf()
- 형식
```c
int scanf(const char *format, ...);
```

- 반환값
    - 정상적으로 입력을 받아 변수에 저장하면 1반환(입력받은 변수 개수)
    - 입력 실패시 EOF(-1) 반환
- 동작과정
    1. 표준 입력 대기
    2. 입력값을 서식문자로 변환
    3. 변수에 저장
    4. 반환값 결정

- 주의할 점
    1. **주소 연산자** 필수
        변수의 값을 변경해야 하므로 **반드시** 변수의 메모리 주소를 전달
    2. 입력 버퍼 문제
    scanf가 데이터를 읽고 나서 입력 버퍼에 개행 문자(\n)가 남는 경우가 있어서 이후 입력이 꼬일 수 있음
    
- 입력 버퍼 문제 해결 방법
    - getchar() 사용
    - fflush(stdin) 사용 (Windows에서만)
    - while (getchar() != '\n');


#### 2개의 입력 값을 받았을 때 4 엔터를 입력한다면?
```c
scanf("%d %d", &num1, &num2);
// 입력: 4 ↵
``` 
scanf는 사용자의 입력을 계속해서 기다림
사용자가 두 번째 숫자를 입력하고 다시 엔터를 눌러야 입력 종료됨

#### 숫자가 아닌 값 입력했을 경우?
```c
scanf("%d %d", &num1, &num2);
// 입력 50 abc
```
scanf 반환값: 1 
num2의 값은 초기화되지않거나 쓰레기 값이 남아있음
입력버퍼에 남아있는 값: → `abc\n` 다음 입력을 받을 때 이전 입력의 찌꺼기가 남아 오류발생할 수 있음

### Q3. 공백을 무시하는 형식지정자?
→ 입력을 받을 때 앞에 남아 있는 공백 문자(스페이스, \t, \n)를 자동으로 건너뛰는 형식 지정자를 의미함.  

📌 공백 문자를 자동으로 무시하는 형식 지정자

- %d (정수)
- %f (실수)
- %s (문자열)
- %u (부호 없는 정수)
- %o (8진수)
- %x (16진수)
- %e, %g, %lf (실수 관련)  


📌 공백 문자를 무시하지 않는 형식 지정자
- %c (문자) : 공백을 무시하지 않음!
- scanf("%c", &ch); → 앞에 남아 있는 개행 문자(\n)까지 입력받을 수 있음.
- 해결방법
    - getchar() 사용
    - scanf(" %c", &ch);처럼 %c 앞에 공백 추가  

### Q4. char을 %d로 출력하는 건 되는데, %d로 입력하는 건 왜 안 됨??
char는 내부적으로 정수(ASCII 코드 값)로 저장되므로, %d로 출력하면 char 값을 int로 변환해서 출력 가능    </br>   char는 1바이트(sizeof(char) = 1), 하지만 %d는 int(4바이트) 크기를 요구함.
scanf("%d", &ch);을 실행하면, 입력된 숫자(예: 65)를 4바이트 크기의 정수(int)로 읽으려 함.
그런데 ch는 1바이트 크기이므로 메모리 크기가 맞지 않아서 잘못된 값이 저장될 가능성이 있음

1kbyte = > 1024byte
k = 2^10
m = k*k = 2^20
g = m*k = 2^30

### Q5. C언어에서 문자열과 배열은 같다고 볼 수 있나?
→ ❌ 
문자열은 문자의 배열이 맞지만 문자열 자체가 배열과 동일하다고 볼 수 없다.
- 배열(Array): 동일한 자료형을 연속적으로 저장하는 자료구조.
- 문자열(String): 널 종료 문자(\0)가 포함된 char 배열.

### Q6. 문자열 배열과 문자리터럴의 메모리영역 차이?
```c
// (1) 문자열 배열
char str[100] = "oragne";       

// (2) 문자 리터럴
printf("%s\n", "orange");       // 출력오류
```
(1) 배열
- str은 스택(Stack) 메모리에 할당
- "orange"의 문자열 데이터가 실제 배열에 복사
- 문자열 수정 가능 
 
(2) 문자열 리터럴
- 문자열 "orange"는 ROD에 저장
- "orange"의 주소가 printf("%s\n", "orange"); 호출 시 전달
- "orange"를 수정하려고 하면 에러 발생. (읽기 전용)


### Q7. C언어의 메모리 영역
C 언어에서 프로그램이 실행될 때 사용하는 메모리 영역은 크게 5가지로 나눌 수 있다.
1. 코드영역
    - 실행할 프로그램의 기계어 코드가 저장
    - 읽기 전용 (Read-Only)
    - 프로그램이 실행될때 변하지 않음
    - 함수의 코드가 저장됨  

2. 읽기 전용 데이터 (ROD)
    - 문자열 리터럴과 const 상수 저장
    - 수정 불가능

3. 데이터 영역
    - 초기화된 데이터 영역 (.data)
        - 프로그램이 종료될 때까지 유지됨
        - 전역변수, static 변수 중 초기값이 있는 변수 저장
    - 초기화 되지 않은 데이터 영역 (BSS)
        - 프로그램 실행 시 자동으로 0 초기화
        - 전역변수, static 변수 중 초기값이 없는 변수  

4. 힙 영역 
    - 실행 중 동적으로 할당된 메모리 저장
    - malloc(), colloc(), readloc()
    - free() 호출하지 않을 경우 메모리 누수 발생  

5. 스택영역 
    - 지역 변수, 함수 호출 스택, 리턴 주소 등..
    - 함수 호출 시 스택 프레임 생성
    - 함수 끝나면 자동으로 해제

참고) 메모리 구조 그림
```scss
낮은 주소
 ┌──────────────────────────┐
 │   코드 영역 (Text)        │ ← 실행할 코드 저장 (읽기 전용)
 ├──────────────────────────┤
 │  읽기 전용 데이터 (ROD)   │ ← **문자열 리터럴, const 변수** (읽기 전용)
 ├──────────────────────────┤
 │  데이터 영역 (Data)       │ 
 │  - .data                 | (초기화된 전역변수, static 변수)
 │  - .bss                  | (초기화되지 않은 전역변수, static 변수)
 ├──────────────────────────┤
 │       힙 영역 (Heap)     │ ← malloc()로 동적 할당
 │           ↓              │
 ├──────────────────────────┤
 │       스택 영역 (Stack)  │ ← 지역 변수, 함수 호출
 │           ↑              │
 └──────────────────────────┘
높은 주소
```
### Q8. `printf("%c\n", "orange");` 가 출력오류인 이유? 
```c
printf("%s\n", "orange");       // 정상출력
printf("%c\n", "orange");       // 오류발생
                                // 한 글자만 가져올 거라 예상함
                                // 출력은 아무것도 나오지 않았음
```
서식 지정자에 따라 전달하는 인자의 타입이 달라야 한다.
- "%s" → char * (문자열의 시작 주소)
- "%c" → char (단일 문자)

따라서 `printf("%c\n", "orange"); ` 를 `printf("%c\n", *"orange"); ` 로 수정할 경우 원하는 결과 `o`가 출력된다.

### Q9. 문자열, 문자 배열, 문자열 리터럴 개념 헷갈려어어어..
✔ 문자열(String):
- 연속된 문자들의 모음으로 \0(널 문자)로 끝남.
- C에서는 문자 배열 또는 문자열 리터럴을 이용해 표현됨.
- 포인터를 사용하면 문자열의 시작 주소를 가리킬 수 있음.  

✔ 문자 배열(Character Array):
- 문자들을 저장할 수 있는 배열. 문자열을 저장할 수도 있음.
- 스택(Stack) 또는 데이터 영역(.data/.bss)에 저장됨.
- 배열이므로 메모리의 독립적인 공간을 가지며 수정 가능!  

✔ 문자열 리터럴(String Literal):
- 읽기 전용 메모리(ROD, .rodata)에 저장되는 문자열.
- 문자열 리터럴을 직접 수정할 수 없음.
- 포인터를 이용해 접근할 수 있지만, 문자 자체를 변경하려 하면 오류 발생 가능.  

➡ 즉, "문자열"이라는 큰 개념 안에 `"문자 배열"`과 `"문자열 리터럴"`이 **하위 개념**으로 존재함.
➡ 문자 배열과 문자열 리터럴은 `문자열` 이라는 개념에서 포인터를 통해 접근 가능
➡ 문자 배열은 **배열** 이므로 독립적인 공간을 가지며 수정 가능
➡ 문자 리터럴은 **리터럴** 이므로 읽기 전용, 내용 수정 불가


### Q10. 문자 배열에 문자열 리터럴이 복사된다고 했는데 원래 리터럴의 주소는 남아있는건가?
➡ 문자열 리터럴의 주소는 그대로 남아 있음!
```c
#include <stdio.h>

int main() {
    char str1[] = "apple";  // 문자 배열 (복사됨)
    char *str2 = "apple";   // 문자열 리터럴 (주소 저장)

    printf("Array str1: %s (주소: %p)\n", str1, str1);
    printf("Literal str2: %s (주소: %p)\n", str2, str2);

    return 0;
}

// 결과 

```